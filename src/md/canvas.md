<h2 align='center'>canvas 小记</h2>

## canvas 属性

1. <\canvas>标签有两个属性，width 和 height，当没有设置时，默认width: 300; height: 150;

2. 可以使用css定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。

> 注意: 如果你绘制出来的图像是扭曲的, 尝试用width和height属性为<\canvas>明确规定宽高，而不是使用CSS。

3. canvas元素有一个getContext()得方法，这个方法就是用来获得渲染上下文和它的绘画功能的。getContext()只有一个参数，上下文的格式。

## 检查支持性

替换内容是用于在不支持 <\canvas> 标签的浏览器中展示的。通过简单的测试getContext()方法的存在，脚本可以检查编程支持性。如下：

```
var canvas = document.getElementById('demo');

if (canvas.getContext){
  var ctx = canvas.getContext('2d');
  // drawing code here
} else {
  // canvas-unsupported code here
}
```

## 栅格

画图之前，要知道**画布栅格**以及**坐标空间**。canvas元素默认被网格所覆盖。通常来说网格中的一个单元相当于canvas元素中的一像素。**栅格的起点为左上角（坐标为（0,0））,所有元素的位置都相对于原点定位。**所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。原点的位置是可以变动的。

## 绘制路径

图形的基本元素是路径。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。

1. 首先，你需要创建路径起始点。
2. 然后你使用画图命令去画出路径。
3. 之后你把路径封闭。
4. 一旦路径生成，你就能通过描边或填充路径区域来渲染图形。

以下是所要用到的函数：

**beginPath()**

新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。(和之前绘制的路径就无关了，不会有连线从之前的路径连到新的路径上)

**closePath()**

闭合路径之后图形绘制命令又重新指向到上下文中。

**stroke()**

通过线条来绘制图形轮廓。

**fill()**

通过填充路径的内容区域生成实心的图形。

> 注意：在**调用beginPath()之后** 或 **canvas刚建的时候**，第一条路径构造命令通常被视为是moveTo（），无论实际上是什么。出于这个原因，你几乎总是要在设置路径之后**专门指定你的起始位置。**
> 注意：当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。

## 移动笔触

一个非常有用的函数，而这个函数实际上并不能画出任何东西，这个函数就是moveTo()。或者你可以想象一下在纸上作业，一支钢笔或者铅笔的笔尖从一个点到另一个点的移动过程。

**moveTo(x,y)**：将笔触移动到指定的坐标x以及y上。

当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径。

## 矩形

rect(x, y, width, height)：绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。

当该方法执行的时候，moveTo()方法**自动设置**坐标参数（0,0）。也就是说，当前笔触**自动重置**回默认坐标。


## 动画的基本步骤

1. **清空 canvas**

除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。

2. **保存 canvas 状态**

如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。

3. **绘制动画图形（animated shapes）**

这一步才是重绘动画帧。

4. **恢复 canvas 状态**

如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。